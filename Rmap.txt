```python
# -------- RMAP helpers --------

_rmap_obj = None
_rmap_idm = None

def _rmap_available() -> bool:
    return bool(app.config.get("RMAP_ENABLE", False))

def _get_rmap():
    nonlocal _rmap_obj, _rmap_idm

    if _rmap_obj is not None and _rmap_idm is not None:
        return _rmap_obj, _rmap_idm

    try:
        from rmap.identity_manager import IdentityManager
        from rmap.rmap import RMAP
    except Exception as e:
        raise RuntimeError(f"RMAP library not available: {e}")

    clients_dir = Path(app.config["RMAP_CLIENT_KEYS_DIR"]).resolve()
    server_priv = Path(app.config["RMAP_SERVER_PRIV"]).resolve()
    server_pub = Path(app.config["RMAP_SERVER_PUB"]).resolve()

    if not clients_dir.exists():
        raise RuntimeError(f"RMAP clients dir not found: {clients_dir}")

    if not server_priv.exists() or not server_pub.exists():
        raise RuntimeError("RMAP server keypair not found")

    from rmap.identity_manager import IdentityManager
    _rmap_idm = IdentityManager(
        client_keys_dir=str(clients_dir),
        server_public_key_path=str(server_pub),
        server_private_key_path=str(server_priv),
        server_private_key_passphrase=app.config.get("RMAP_SERVER_PRIV_PASSPHRASE"),
    )

    from rmap.rmap import RMAP
    _rmap_obj = RMAP(_rmap_idm)
    return _rmap_obj, _rmap_idm

# -------- RMAP endpoints --------

@app.post("/api/rmap-initiate")
def rmap_initiate():
    if not _rmap_available():
        return jsonify({"error": "RMAP disabled"}), 404

    payload_b64 = (request.get_json(silent=True) or {}).get("payload")
    if not payload_b64 or not isinstance(payload_b64, str):
        return jsonify({"error": "payload required"}), 400

    try:
        rmap, _ = _get_rmap()
        res = rmap.handle_message1({"payload": payload_b64})

        app_logger.info(
            "rmap.message1",
            extra={"result_keys": list(res.keys()) if isinstance(res, dict) else "non-dict"},
        )

        if isinstance(res, dict) and "payload" in res:
            return jsonify({"payload": res["payload"]}), 200

        if isinstance(res, dict) and "error" in res:
            return jsonify(res), 400

        return jsonify({"error": "unexpected RMAP response"}), 500

    except Exception as e:
        app_logger.error("rmap.initiate.error", extra={"error": str(e)})
        return jsonify({"error": f"rmap initiation failed: {e}"}), 400


@app.post("/api/rmap-get-link")
def rmap_get_link():
    if not _rmap_available():
        return jsonify({"error": "RMAP disabled"}), 404

    payload_b64 = (request.get_json(silent=True) or {}).get("payload")
    if not payload_b64 or not isinstance(payload_b64, str):
        return jsonify({"error": "payload required"}), 400

    try:
        rmap, idm = _get_rmap()
        res = rmap.handle_message2({"payload": payload_b64})

        if isinstance(res, dict) and "error" in res:
            app_logger.info("rmap.message2.error", extra={"error": res.get("error")})
            return jsonify(res), 400

        if not (isinstance(res, dict) and "result" in res and isinstance(res["result"], str)):
            app_logger.error("rmap.message2.unexpected", extra={"got": str(res)})
            return jsonify({"error": "unexpected RMAP response"}), 500

        result_hex = res["result"].lower()

        # extract nonceServer by decrypting the payload, fallback to scanning rmap state
        try:
            obj = idm.decrypt_for_server(payload_b64)
            nonce_server = int(obj.get("nonceServer"))
        except Exception:
            nonce_server = None

        identity = None
        try:
            for ident, (_nc, ns) in dict(getattr(rmap, "nonces", {})).items():
                if nonce_server is not None and int(ns) == int(nonce_server):
                    identity = ident
                    break
        except Exception:
            identity = None

        if identity is None:
            identity = "unknown"

        secret_hex = result_hex
        link_token = result_hex

        # Find base document
        doc_id_env = app.config.get("RMAP_DOCUMENT_ID")
        if not doc_id_env:
            return jsonify({"error": "RMAP_DOCUMENT_ID not configured"}), 500

        try:
            base_doc_id = int(doc_id_env)
        except (TypeError, ValueError):
            return jsonify({"error": "RMAP_DOCUMENT_ID must be an integer"}), 500

        try:
            with get_engine().connect() as conn:
                row = conn.execute(
                    text("SELECT id, name, path FROM Documents WHERE id = :id LIMIT 1"),
                    {"id": base_doc_id},
                ).first()
        except Exception as e:
            app_logger.error(
                "db.query.error",
                extra={"where": "rmap_get_link.select_doc", "error": str(e)},
            )
            return jsonify({"error": f"database error: {str(e)}"}), 503

        if not row:
            return jsonify({"error": "base document not found"}), 404

        storage_root = Path(app.config["STORAGE_DIR"]).resolve()
        file_path = Path(row.path)
        if not file_path.is_absolute():
            file_path = storage_root / file_path
        file_path = file_path.resolve()

        try:
            file_path.relative_to(storage_root)
        except ValueError:
            app_logger.warning("path.escape.detected", extra={"path": str(file_path)})
            return jsonify({"error": "document path invalid"}), 500

        if not file_path.exists():
            return jsonify({"error": "file missing on disk"}), 410

        method = app.config.get("RMAP_WATERMARK_METHOD", "gulshan")
        key = app.config.get("RMAP_WATERMARK_KEY", app.config["SECRET_KEY"])

        try:
            applicable = WMUtils.is_watermarking_applicable(
                method=method, pdf=str(file_path), position=None
            )
            if applicable is False:
                app_logger.info(
                    "wm.inapplicable",
                    extra={"method": method, "doc": str(file_path)},
                )
                return jsonify({"error": "configured watermarking method not applicable"}), 400
        except Exception as e:
            app_logger.error("wm.applicability.error", extra={"error": str(e)})
            return jsonify(
                {"error": f"watermark applicability check failed: {e}"}
            ), 400

        try:
            wm_bytes: bytes = WMUtils.apply_watermark(
                pdf=str(file_path),
                secret=secret_hex,
                key=str(key),
                method=str(method),
                position=None,
            )
            if not isinstance(wm_bytes, (bytes, bytearray)) or len(wm_bytes) == 0:
                return jsonify({"error": "watermarking produced no output"}), 500
        except Exception as e:
            app_logger.error("wm.apply.error", extra={"error": str(e)})
            return jsonify({"error": f"watermarking failed: {e}"}), 500

        base_name = Path(row.name or file_path.name).stem
        intended_slug = secure_filename(str(identity) or "recipient")
        dest_dir = file_path.parent / "watermarks"
        dest_dir.mkdir(parents=True, exist_ok=True)
        candidate = f"{base_name}__{intended_slug}.pdf"
        dest_path = dest_dir / candidate

        try:
            with dest_path.open("wb") as f:
                f.write(wm_bytes)
        except Exception as e:
            app_logger.error(
                "fs.write.error", extra={"path": str(dest_path), "error": str(e)}
            )
            return jsonify(
                {"error": f"failed to write watermarked file: {e}"}
            ), 500

        try:
            _ensure_wm_key_column()
        except Exception:
            pass

        try:
            with get_engine().begin() as conn:
                conn.execute(
                    text(
                        """
                        INSERT INTO Versions (
                            documentid, link, intended_for,
                            secret, method, wm_key, position, path
                        )
                        VALUES (
                            :documentid, :link, :intended_for,
                            :secret, :method, :wm_key, :position, :path
                        )
                        """
                    ),
                    {
                        "documentid": int(row.id),
                        "link": link_token,
                        "intended_for": str(identity),
                        "secret": secret_hex,
                        "method": str(method),
                        "wm_key": str(key),
                        "position": "",
                        "path": str(dest_path),
                    },
                )
        except IntegrityError:
            try:
                dest_path.unlink(missing_ok=True)
            except Exception:
                pass
            app_logger.info("version.dup_link", extra={"link": link_token})
            return jsonify({"error": "version link already exists"}), 409
        except Exception as e:
            try:
                dest_path.unlink(missing_ok=True)
            except Exception:
                pass
            app_logger.error(
                "db.insert.error",
                extra={"table": "Versions", "error": str(e)},
            )
            return jsonify(
                {"error": f"database error during version insert: {e}"}
            ), 503

        app_logger.info(
            "rmap.issued", extra={"identity": identity, "link": link_token}
        )
        return jsonify({"result": link_token, "identity": identity}), 200

    except Exception as e:
        app_logger.error("rmap.get_link.error", extra={"error": str(e)})
        return jsonify({"error": f"rmap get-link failed: {e}"}), 400
```

Sources
[1] server.py https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/143627732/aab4d94d-7334-41b1-82f4-44dc02e29a75/server.py
